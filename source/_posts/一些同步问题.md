# 一些同步问题

## 移动同步的实现方案

### 主控端

收到玩家操作后立刻本地执行,并在客户端保存一个未确认的移动列表(SavedMoves)(移动前位置,移动后的位置,速度,DeltaTime,朝向...),每帧都会将所有未确认的移动列表发送给服务器校验移动是否合法,如果合法,服务器发送确认的RPC,客户顿收到RPC后从SavedMoves中移除确认的移动.如果不合法(与服务器不一致)那么将用服务器的权威位置回滚客户端的位置,然后进行前滚操作,把SavedMoves中未确认的移动重新执行一遍.

### 模拟端

这里用[UE的思路](https://github.com/chaosrings/SomeNotes/blob/master/source/_posts/UECharacterMovement_SimulateProxy.md)
,DS定时向客户端同步移动状态(位置,速度),比较关注实时性,所以可能与服务器位置有偏差,大多数都是外插值.

#### 没有物理模拟

影子跟随算法,每次收到服务器同步的移动信息,逻辑体直接设置到对应的位置,同时将速度设置到服务器同步下来的速度,美术体(Mesh)保持在原地.

每次Tick

先用服务器的权威速度预测移动逻辑体,这个预测移动可以关闭

然后插值平滑美术体与逻辑体的相对位置,直到美术体追上逻辑体

#### 带物理模拟

追求实时性,力求同一时刻,客户端上的Actor位置与服务器上的Actor位置差距尽可能小.

收到服务器权威的移动信息保存下来,在每次的物理模拟之前,使用ProjectiveVelocityBlending进行预测,修改Actor的位置速度信息.

关键思路

1. 根据单向网络延迟,预测此刻服务器上Actor的位置.

2. 根据预测的服务器位置与客户端本地的位置,来插值修正客户端的位置与速度

3. 如果偏差过大,则强制用服务器上的位置与速度信息覆盖本地的位置与速度信息再进行模拟.


## 客户端帧率不稳/网络波动/丢包 怎么办

- 1.服务器接受移动包后不立刻执行,放在队列中,每个Tick取出执行(其实是一个trade-off,队列大的话延时高,队列小的话抗抖动能力弱)
 
- 2.冗余发包,每次发包并不是只发单帧的移动包,而是发送所有未被服务器确认的包,这样即使丢掉了其中一帧的包,也能够用后面发的包补上

- 3.一定时间后未收到客户端的移动包,服务器强制使用上一次的移动包进行执行,只拉扯网络不好的玩家,不影响其他玩家的体验.

## 变速齿轮怎么防

服务器统计每秒收到的包平均数量,如果超过了给定的阈值(如每秒31个),则认为使用了变速齿轮,进行作弊判定

UE的思路,累加客户端发包的DeltaTime与服务器的DeltaTime,如果两个累加值差距过大,则使用服务器的DeltaTime来进行移动.

## 延迟补偿怎么做

两种类型,带轨迹的子弹,与射线子弹

### 带轨迹子弹

主控客户端直接预创建子弹,发送RPC到服务器后服务器根据客户端的网络延迟进行Tick对应的DeltaTime.等到服务器的子弹创建出来并同步到客户端时,也对创建出来的子弹根据网络延迟Tick对应的时间.

### 无轨迹子弹

主控端进行射线检测,并把本地判定命中的Actor信息发送给服务器,服务器收到开火RPC时将所有其他角色的位置回滚到(网络延迟)之前来进行命中判定,同时,如果是客户端上报命中的角色则更容易判定命中.

## 回放怎么做

定时保存整个世界的状态快照(比如1s?),两个快照之间每帧保存差量数据.
补充?

## 可靠UDP

- 每个包给序号,收到后需发送ACK序号
- 超时未收到ACK则需要重传,如果连续收到了后面包的确认则不等超时进行快重传.
- 保序
  简单做法: 必须按序收到,提前收到的直接丢弃
  好一些的做法: 乱序收到的保存在缓存中,每收到一个包判断缓存中的包序号是否连续,连续则批量处理提交应用层.
  
- 滑动窗口,发包时,如果包序号大于最后一个确认的序号+窗口值则不发送,根据丢包情况调整窗口大小.

